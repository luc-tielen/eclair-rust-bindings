use super::internal;

// A cursor is a helper datastructure for serializing data back and forth
// between Rust and Eclair. It lives less long than the associated program.
// The raw pointer has the same lifetime as the program, and is advanced when
// values are read/written from/to the buffer.

pub struct ReadCursor<'a> {
    prog: &'a internal::Program,
    ptr: *mut u32,
}

pub struct WriteCursor<'a> {
    prog: &'a mut internal::Program,
    ptr: *mut u32,
}

pub trait Marshal {
    fn serialize(&self, buf: &mut WriteCursor);
    fn deserialize(buf: &mut ReadCursor) -> Self;
}

impl Marshal for u32 {
    fn serialize(&self, buf: &mut WriteCursor) {
        buf.write_u32(*self)
    }

    fn deserialize(buf: &mut ReadCursor) -> Self {
        buf.read_u32()
    }
}

// NOTE: we use String here since the value needs to live longer than the Cursor
impl Marshal for String {
    fn serialize(&self, buf: &mut WriteCursor) {
        buf.write_str(self)
    }

    fn deserialize(buf: &mut ReadCursor) -> Self {
        buf.read_str().into()
    }
}

impl<'a> ReadCursor<'a> {
    pub fn new(prog: &'a internal::Program, ptr: *mut u32) -> Self {
        Self { prog, ptr }
    }

    fn update_buf_ptr(&mut self) {
        // SAFETY: This code is only called via code generated by the Marshal proc-macro.
        // A crash can only occur if the Rust struct binding to the Datalog fact doesn't have the
        // structure as in Eclair Datalog.
        self.ptr = unsafe { self.ptr.add(1) }
    }

    fn read_u32(&mut self) -> u32 {
        // SAFETY: This code is only called via code generated by the Marshal proc-macro.
        // A crash can only occur if the Rust struct binding to the Datalog fact doesn't have the
        // structure as in Eclair Datalog.
        let value = unsafe { *self.ptr };
        self.update_buf_ptr();
        value
    }

    fn read_str(&mut self) -> &str {
        let idx = internal::StringIndex(self.read_u32());
        self.prog
            .decode_string(&idx)
            // This should always work.. if not => bug in Eclair
            .expect(
                "Tried to deserialize an Eclair string that was not stored in the symbol table!",
            )
    }
}

impl<'a> WriteCursor<'a> {
    pub fn new(prog: &'a mut internal::Program, ptr: *mut u32) -> Self {
        Self { prog, ptr }
    }

    fn update_buf_ptr(&mut self) {
        // SAFETY: This code is only called via code generated by the Marshal proc-macro.
        // A crash can only occur if the Rust struct binding to the Datalog fact doesn't have the
        // structure as in Eclair Datalog.
        self.ptr = unsafe { self.ptr.add(1) }
    }

    fn write_u32(&mut self, value: u32) {
        // SAFETY: This code is only called via code generated by the Marshal proc-macro.
        // A crash can only occur if the Rust struct binding to the Datalog fact doesn't have the
        // structure as in Eclair Datalog.
        unsafe {
            *self.ptr = value;
        }
        self.update_buf_ptr();
    }

    fn write_str(&mut self, s: &str) {
        let idx = self.prog.encode_string(s);
        self.write_u32(idx.0);
    }
}
